<HTML>
<HEAD><TITLE>src/csvbankin.web</TITLE></HEAD>
<BODY>
<P><A NAME="module_1"></A><HR NOSHADE SIZE=4></HR><B>1. *.</B>#*csvbankin
</P>

<PRE>
#p 
    use warnings;
    use strict;
    use YAML::Syck;
    use YAML::AppConfig;
    use Getopt::Long;
    Getopt::Long::Configure ('bundling');
    &lt;&lt;sub determine_action&gt;&gt;<A HREF="#module_6"><SUB>6</SUB></A>
</PRE>
<P><A NAME="module_2"></A><HR NOSHADE SIZE=1></HR>2. an outline of the program in logical order.
</P>

<P>the core of the program is three things:
</P>

<P>1. parsing the fields of the input file and selecting a standardized set of these
2. matching an account to each input line, by looking for known match strings
3. remembering new account/match string combinations.
</P>

<P>the program runs in two passes: the first two steps in the first pass, the third step in the second pass. Let's look at what is needed for each of these.
</P>

<P><A NAME="module_3"></A><HR NOSHADE SIZE=1></HR>3. A note about structure: subroutine chaining.
</P>

<P>the program is structured as much as possible into subroutines that take input and provide output. So a lot of the actual body of the program will look like this:
</P>

<P>bar = subroutine(foo);
baz = subroutine(bar);
bim = subroutine(baz);
</P>

<P>etc.
</P>

<P>In the following, I will generally first describe the subroutines and show their code, and at the end describe how they are used and show the blocks of code that call the subroutines.
</P>

<P><A NAME="module_4"></A><HR NOSHADE SIZE=4></HR><B>4. *.</B>#*Introduction to csvbankin
</P>

<P>    <CODE>Csvbankin</CODE> parses diverse csv bank statements to a single format and remembers mappings of transactions to accounts. It is intended to prepare statements from different banks, which might all have different csv formats for their statements, to one standardized format for import into a finance management program. The need arose for me because <CODE>Moneyguru</CODE>, the package I was using, has a good csv import routine that can remember what accounts to map transactions to given the presence of a field with an internal account name, but it can't derive those account names from the text of the transaction itself. So, that's the second thing <CODE>csvbankin</CODE> does: it learns to recognize which account a transaction should be mapped to based on match strings in the text of the input file.
</P>

<P><A NAME="module_5"></A><HR NOSHADE SIZE=1></HR>5. Structure of the program
</P>

<P>    To accomplish this purpose, <CODE>csvbankin</CODE> runs in two steps. First, it parses the lines from the input file, and compares them to its list of accounts and match strings to determine what accounts go with each transaction. It prints these matches in an intermediate file which the user must inspect, adding new match strings and account names. Second, <CODE>csvbankin</CODE> reads this intermediate file to produce the final output file, and adds any new account names and match strings to its list to use next time. The idea is that over time, the amount of manual intervention decreases, because <CODE>csvbankin</CODE> remembers more and more matches.
</P>

<P><A NAME="module_6"></A><HR NOSHADE SIZE=1></HR>6. determine what to do
</P>

<P>before we start reading in data, we need to determine what ne need to do.
</P>

<PRE>
&lt;&lt;sub determine_action&gt;&gt; =
sub determine_action{    
    my %h = ();
    GetOptions (\%h, 'r|read', 'w|write', 'o|output=s', 'a|account=s'); # THIS SHOULD BE IN GLOBAL NAMESPACE!
    my ($output,$read,$write,$name_or_type_b,$input_account);

    my $argument = shift @ARGV;

    if($h{r}==1){
        if(!$h{a} or $h{a}eq''){
            print "in read mode, need an account type or name! exiting.\n";
            exit;
        }# ^^ r but not a
        elsif($h{a} and !$h{a}eq''){
            ($input_account, $name_or_type_b) = resolve_input_account($h{a});
            $read = 1;
        }# ^^ r and a
    }
    if(defined $h{w}){
        if (!$h{o} or $h{o}eq''){
            print "in write mode, need output filename! exiting.\n";
            exit;
        }# ^^ w but not o
        elsif($h{o} and !$h{o}eq''){
                $output = $h{o};
                print "assigned o value $h{o} to \$output!\n";
                $write = 1;
        }# ^^ w and o
    }else{
        if (!$h{o}eq''){
            print "no point specifying output file if not in write mode! exiting.\n";
            exit;
        }# ^^ o but not w
        elsif(!$h{o} or $h{o}eq''){

            print "neither o nor w specified, I hope we have something to read!\n";
        }# ^^ neither o nor w
    }
    return ($read, $write, $format, $assoc_account);
}
1;
<UL>
<LI>sub determine_action: 1, <EM>6</EM>
</UL>
</BODY></HTML>
